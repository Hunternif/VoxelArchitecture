package hunternif.voxarch.sandbox.castle.wfc

import hunternif.voxarch.vector.Array3D

// Famous demos by Marian42 and Oskar Stalberg use 3d tiles of static size.
// Since I want my structures style-able via "CSS", I'll use abstract
// representations of tiles, without explicit block sizes.
// I'll use "tile size" for measuring distance.

// "WFC tile" is a 3d cube.
// Different types of content inside the tile are represented by colored voxels.
// So the tile is essentially a NxNxN storage of [WfcVoxel].
// During execution of WFC the constraint solver will match the voxels on
// adjacent tiles, so that wall connects to a wall, air connects to air etc.
// Voxels can also be easily rendered to pixels in snapshot tests.


// I will start with N = 3. This number can be changed at any point.
// But 3 seems like it would require a relatively small number of manual
// definitions, and many variants can be generated by rotating and mirroring.

// Imagine a cross-section of a castle corridor, with walls on the left and right.
// It would be composed of 2 tiles, each with a wall in the middle.

class WfcGrid(width: Int, height: Int, length: Int):
    Array3D<WfcTile>(width, length, height, air)

class WfcTile(init: (x: Int, y: Int, z: Int) -> WfcVoxel) :
    Array3D<WfcVoxel>(3, 3, 3, init) {
    constructor(vx: WfcVoxel): this({ _, _, _ -> vx })
}

enum class WfcVoxel {
    AIR, WALL, FLOOR
}
