package hunternif.voxarch.wfc

import hunternif.voxarch.wfc.Direction.*
import hunternif.voxarch.vector.Array3D
import hunternif.voxarch.vector.IntVec3
import java.util.*
import kotlin.math.log
import kotlin.random.Random

// Famous demos by Marian42 and Oskar Stalberg use 3d tiles of static size.
// Since I want my structures style-able via "CSS", I'll use abstract
// representations of tiles, without explicit block sizes.
// I'll use "tile size" for measuring distance.

// "WFC tile" is a 3d cube.
// Different types of content inside the tile are represented by colored voxels.
// So the tile is essentially a NxNxN storage of [WfcVoxel].
// During execution of WFC the constraint solver will match the voxels on
// adjacent tiles, so that wall connects to a wall, air connects to air etc.
// Voxels can also be easily rendered to pixels in snapshot tests.


// I will start with N = 3. This number can be changed at any point.
// But 3 seems like it would require a relatively small number of manual
// definitions, and many variants can be generated by rotating and mirroring.

// Imagine a cross-section of a castle corridor, with walls on the left and right.
// It would be composed of 2 tiles, each with a wall in the middle.

/**
 * This tile represents a possible final state of a slot in the wave's 3d grid.
 * Each slot will collapse into one of these tiles.
 */
interface WfcTile {
    /**
     * Returns true if this tile matches to [other] tile that is placed adjacent
     * to it from direction [dir].
     */
    fun matchesSide(other: WfcTile, dir: Direction): Boolean
}

/** A single cell in the wave's 3d grid. */
private class WfSlot<T: WfcTile>(
    val possibleStates: MutableSet<T>
) {
    /** Final collapsed state of this slot */
    var state: T? = null
        private set
    fun setState(state: T) {
        this.state = state
        possibleStates.clear()
        possibleStates.add(state)
    }
    fun entropy(): Float =
        if (possibleStates.size <= 1) 0f
        else -log(1f/possibleStates.size.toFloat(), 2f)
}

class WfcGrid<T: WfcTile>(
    private val width: Int,
    private val height: Int,
    private val length: Int,
    private val tileset: List<T>,
    seed: Long = 0L
) {
    private val rand = Random(seed)
    private var collapsedCount = 0
    private val totalCount = width * height * length
    private val wave by lazy {
        Array3D(width, height, length) {_, _, _ ->
            WfSlot(tileset.toMutableSet())
        }
    }

    /** Collapse tiles at the edge of the grid to be [air]. */
    fun setAirBoundary(air: T) = setAirAndGroundBoundary(air, air, air)

    /**
     * Collapse tiles at the edge of the grid to be [air],
     * on the bottom Y layer to be [ground],
     * and on the perimeter at y=1 to be [groundedAir].
     * "Grounded air" means "ground below + air above".
     */
    fun setAirAndGroundBoundary(air: T, groundedAir: T, ground: T) {
        for (p in wave) {
            if (p.y >= height-1) setState(p, air)
            else if (p.y <= 0) setState(p, ground)
            else if (p.x <= 0 || p.x >= width-1 ||
                p.z <= 0 || p.z >= length-1) {
                if (p.y <= 1) setState(p, groundedAir)
                else setState(p, air)
            }
        }
        propagate(IntVec3(1, 0, 1))
    }

    private fun setState(p: IntVec3, tile: T) {
        wave[p].setState(tile)
        collapsedCount++
    }

    fun getCollapsedTiles(): Array3D<T?> = Array3D(width, height, length)
        { x, y, z -> wave[x, y, z].state }

    val isCollapsed: Boolean get() = collapsedCount >= totalCount
    var isContradicted: Boolean = false
        private set

    /**
     * Performs 1 step of the Wave Function Collapse algo:
     * - picks a slot with the lowest entropy and collapses it
     * - propagates constraints resulting from this collapse
     */
    fun collapseStep() {
        if (isCollapsed) {
            println("Nothing to collapse!")
            return
        }
        val pos = findLowestEntropyPos()
        if (pos == null) {
            isContradicted = true
            println("Contradiction!")
            return
        }
        setState(pos, wave[pos].possibleStates.random(rand))
        propagate(pos)
    }

    /** Returns the position of the slot with the lowest non-zero entropy. */
    private fun findLowestEntropyPos(): IntVec3? {
        var min = Float.MAX_VALUE
        var argMin: IntVec3? = null
        for (p in wave) {
            val entropy = wave[p].entropy()
            if (entropy > 0 && entropy < min) {
                argMin = p
                min = entropy
            }
        }
        return argMin
    }

    /**
     * Propagates constraints to the entire grid after the given slot collapsed.
     */
    private fun propagate(from: IntVec3) {
        val propagationQueue = LinkedList<IntVec3>().apply { add(from) }
        while (propagationQueue.isNotEmpty()) {
            val pos = propagationQueue.pop()
            for (p in pos.allDirections()) {
                if (p !in wave || wave[p].state != null) continue
                if (constrainStates(p)) {
                    propagationQueue.add(p)
                }
            }
        }
    }
    /**
     * Removes from "possibleStates" any states that can't be matched to its
     * neighbors. Returns true if at least 1 state was removed.
     */
    private fun constrainStates(pos: IntVec3): Boolean {
        val originalCount = wave[pos].possibleStates.size
        for (dir in Direction.values()) {
            val adjPos = pos.add(dir.vec)
            if (adjPos !in wave) continue
            val adjSlot = wave[adjPos]
            wave[pos].possibleStates.removeIf { state ->
                adjSlot.possibleStates.none { state.matchesSide(it, dir) }
            }
        }
        val newCount = wave[pos].possibleStates.size
        if (newCount == 1) setState(pos, wave[pos].possibleStates.first())
        return newCount < originalCount
    }
}

enum class Direction(val vec: IntVec3) {
    UP(IntVec3(0, 1, 0)),
    DOWN(IntVec3(0, -1, 0)),
    EAST(IntVec3(1, 0, 0)),
    SOUTH(IntVec3(0, 0, 1)),
    WEST(IntVec3(-1, 0, 0)),
    NORTH(IntVec3(0, 0, -1))
}

private fun IntVec3.allDirections(): Sequence<IntVec3> = sequence {
    yield(add(DOWN.vec))
    yield(add(UP.vec))
    yield(add(NORTH.vec))
    yield(add(EAST.vec))
    yield(add(SOUTH.vec))
    yield(add(WEST.vec))
}
