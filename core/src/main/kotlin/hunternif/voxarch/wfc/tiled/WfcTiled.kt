package hunternif.voxarch.wfc.tiled

import hunternif.voxarch.util.*
import hunternif.voxarch.wfc.WfcSlot
import hunternif.voxarch.wfc.WfcModel

// Famous demos by Marian42 and Oskar Stalberg use 3d tiles of static size.
// Since I want my structures style-able via "CSS", I'll use abstract
// representations of tiles, without explicit block sizes.
// I'll use "tile size" for measuring distance.

// "WFC tile" is a 3d cube.
// Different types of content inside the tile are represented by colored voxels.
// So the tile is essentially a NxKxN storage of [WfcVoxel].
// During execution of WFC the constraint solver will match the voxels on
// adjacent tiles, so that wall connects to a wall, air connects to air etc.
// Voxels can also be easily rendered to pixels in snapshot tests.


// I will start with N = 3. This number can be changed at any point.
// But 3 seems like it would require a relatively small number of manual
// definitions, and many variants can be generated by rotating and mirroring.

// Imagine a cross-section of a castle corridor, with walls on the left and right.
// It would be composed of 2 tiles, each with a wall in the middle.

/**
 * This tile represents a possible final state of a slot in the wave's 3d grid.
 * Each slot will collapse into one of these tiles.
 */
interface WfcTile : IRandomOption {
    /**
     * Returns true if this tile matches to [other] tile that is placed adjacent
     * to it from direction [dir].
     */
    fun matchesSide(other: WfcTile, dir: Direction3D): Boolean
}

class WfcTiledModel<T: WfcTile>(
    width: Int,
    height: Int,
    length: Int,
    tileset: Collection<T>,
    seed: Long = 0L
) : WfcModel<T, T>(width, height, length, tileset, seed) {

    override fun WfcSlot<T, T>.selectDefiniteState(): T =
        rand.nextWeighted(possiblePatterns)

    override fun WfcSlot<T, T>.constrainPatterns(): Boolean {
        val originalCount = possiblePatterns.size
        val directions = Direction3D.values()
            .filter { pos.facing(it) in wave }
            .sortedBy { wave[pos.facing(it)].possiblePatterns.size }
        for (dir in directions) {
            val adjSlot = wave[pos.facing(dir)]
            possiblePatterns.removeIf { state ->
                adjSlot.state?.let { !state.matchesSide(it, dir) } ?:
                adjSlot.possiblePatterns.none { state.matchesSide(it, dir) }
            }
        }
        val newCount = possiblePatterns.size
        if (newCount < originalCount) {
            if (newCount == 1) setState(possiblePatterns.first())
            return true
        }
        return false
    }
}