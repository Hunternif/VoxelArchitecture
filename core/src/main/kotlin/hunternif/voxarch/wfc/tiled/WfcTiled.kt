package hunternif.voxarch.wfc.tiled

import hunternif.voxarch.storage.IStorage3D
import hunternif.voxarch.util.*
import hunternif.voxarch.vector.Array3D
import hunternif.voxarch.vector.IntVec3
import hunternif.voxarch.wfc.WfcSlot
import hunternif.voxarch.wfc.WfcModel
import kotlin.math.log

// Famous demos by Marian42 and Oskar Stalberg use 3d tiles of static size.
// Since I want my structures style-able via "CSS", I'll use abstract
// representations of tiles, without explicit block sizes.
// I'll use "tile size" for measuring distance.

// "WFC tile" is a 3d cube.
// Different types of content inside the tile are represented by colored voxels.
// So the tile is essentially a NxKxN storage of [WfcVoxel].
// During execution of WFC the constraint solver will match the voxels on
// adjacent tiles, so that wall connects to a wall, air connects to air etc.
// Voxels can also be easily rendered to pixels in snapshot tests.


// I will start with N = 3. This number can be changed at any point.
// But 3 seems like it would require a relatively small number of manual
// definitions, and many variants can be generated by rotating and mirroring.

// Imagine a cross-section of a castle corridor, with walls on the left and right.
// It would be composed of 2 tiles, each with a wall in the middle.

/**
 * This tile represents a possible final state of a slot in the wave's 3d grid.
 * Each slot will collapse into one of these tiles.
 */
interface WfcTile : IRandomOption {
    /**
     * Returns true if this tile matches to [other] tile that is placed adjacent
     * to it from direction [dir].
     */
    fun matchesSide(other: WfcTile, dir: Direction3D): Boolean
}

/** A single cell in the wave's 3d grid. */
class WfcTileSlot<T: WfcTile>(
    pos: IntVec3,
    val possibleStates: MutableSet<T>
) : WfcSlot<T>(pos)

class WfcTiledModel<T: WfcTile>(
    width: Int,
    height: Int,
    length: Int,
    private val tileset: List<T>,
    seed: Long = 0L
) : WfcModel<T, WfcTileSlot<T>>(width, height, length, seed), IStorage3D<T?> {

    override val wave: Array3D<WfcTileSlot<T>> by lazy {
        val initialEntropy = calculateEntropy(tileset)
        Array3D(width, height, length) { x, y, z ->
            WfcTileSlot(IntVec3(x, y, z), tileset.toMutableSet()).also {
                it.entropy = initialEntropy
                unobservedSet.add(it)
            }
        }
    }

    override fun WfcTileSlot<T>.selectDefiniteState(): T =
        rand.nextWeighted(possibleStates)

    override fun WfcTileSlot<T>.setDefiniteState(newState: T) {
        state = newState
        possibleStates.clear()
        possibleStates.add(newState)
        updateEntropy()
    }

    override fun WfcTileSlot<T>.relaxConstraints(): Boolean {
        state = null
        if (possibleStates.addAll(tileset)) {
            updateEntropy()
            return true
        }
        return false
    }

    override fun WfcTileSlot<T>.constrainStates(): Boolean {
        val originalCount = possibleStates.size
        val directions = Direction3D.values()
            .filter { pos.facing(it) in wave }
            .sortedBy { wave[pos.facing(it)].possibleStates.size }
        for (dir in directions) {
            val adjSlot = wave[pos.facing(dir)]
            possibleStates.removeIf { state ->
                adjSlot.possibleStates.none { state.matchesSide(it, dir) }
            }
        }
        val newCount = possibleStates.size
        if (newCount < originalCount) {
            if (newCount == 1) setState(possibleStates.first())
            else updateEntropy()
            return true
        }
        return false
    }

    override operator fun iterator(): Iterator<IntVec3> = wave.iterator()
    override fun get(x: Int, y: Int, z: Int): T? = wave[x, y, z].state
    override fun get(p: IntVec3): T? = get(p.x, p.y, p.z)
    override fun set(x: Int, y: Int, z: Int, v: T?) { wave[x, y, z].setState(v) }
    override fun set(p: IntVec3, v: T?) { wave[p].setState(v) }
    override operator fun contains(p: IntVec3) = wave.contains(p)
    override fun contains(x: Int, y: Int, z: Int) = wave.contains(x, y, z)

    fun getPossibleStates(p: IntVec3): Set<T> = getPossibleStates(p.x, p.y, p.z)
    fun getPossibleStates(x: Int, y: Int, z: Int): Set<T> = wave[x, y, z].possibleStates

    private fun calculateEntropy(possibleStates: Collection<WfcTile>): Double {
        val sumTotal = possibleStates.sumOf { it.probability }
        return if (possibleStates.size <= 1) 0.0
        else possibleStates.sumOf {
            -it.probability * log(it.probability/sumTotal, 2.0)
        }
    }

    private fun WfcTileSlot<T>.updateEntropy() {
        unobservedSet.remove(this)
        // update entropy after removal, because it defines position in TreeSet
        entropy = calculateEntropy(possibleStates)
        if (state == null) unobservedSet.add(this)
    }
}